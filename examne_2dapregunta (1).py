# -*- coding: utf-8 -*-
"""Examne_2daPregunta

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12g-O0lYnGczWmxeAhXfKx_TWSKyavIuj

2.      Selección un datatset tabular de al menos 14 columnas, 1000 filas. Si elige imágenes igualmente puede convertir la imagen en datos tabulares de NxM. De esta selección indique cual es la clase o si no tiene.

Complemente con lo siguiente:

a.       Sin el uso de librerías en Python programe el percentil y cuartil de cada columna. Que distribución se puede aplicar en su caso normal, Bernoulli, gaussiana, poisson, otros. Indique la razón de su uso graficando con matplotlib.

b.      De al menos tres columnas seleccionadas por usted indique que datos son relevantes de estas, grafique la misma (puede ser dispersión o mapa de calor, otros), indique al menos 4 características por columna seleccionada.

c.       Obteniendo la media, mediana, moda con el uso de librerías, grafique un diagrama de cajas-bigote de al menos 3 columnas. Explique el resultado.
"""

import pandas as pd

from google.colab import drive
drive.mount("/content/Drive")

df = pd.read_csv("/content/Drive/MyDrive/datos/Insiso2.csv")

# Configurar opciones de visualización
pd.set_option('display.max_columns', None)  # Muestra todas las columnas
pd.set_option('display.max_rows', None)     # Muestra todas las filas
pd.set_option('display.max_colwidth', 20)   # Ajusta el ancho de las columnas a 20 caracteres (opcional)

# Convertir la columna de fechas a formato datetime si no lo está ya
df['Marca de tiempo'] = pd.to_datetime(df['Marca de tiempo'], errors='coerce')

# Convertir las fechas a días desde el 1 de enero de 2022 (Epoch time)
df['dias_desde_2022'] = (df['Marca de tiempo'] - pd.Timestamp("2022-01-01")).dt.days

# Reemplazar la columna Marca de tiempo con la columna dias_desde_2022
df.drop('Marca de tiempo', axis=1, inplace=True)
df.rename(columns={'dias_desde_2022': 'Marca de tiempo'}, inplace=True)
# Función para convertir los rangos de edad a puntos medios
def rango_a_punto_medio(rango):
    try:
        limites = rango.split('-')  # Dividir el rango en límites inferior y superior
        if len(limites) == 2:  # Verificar que se obtuvieron dos límites
            limite_inferior = int(limites[0])  # Convertir el límite inferior a entero
            limite_superior = int(limites[1])  # Convertir el límite superior a entero
            return (limite_inferior + limite_superior) / 2  # Calcular el punto medio
    except (ValueError, AttributeError):  # Manejar errores si la conversión falla
        return rango  # Retornar el valor original en caso de error
    return None  # Retornar None si no se pudo calcular el punto medio

# Aplicar la conversión a la columna de edad
# Supongamos que la columna se llama 'Edad'; ajusta el nombre según tu DataFrame
df['Edad'] = df['Edad'].apply(rango_a_punto_medio)
# Función para convertir valores a numéricos cuando sea posible
def convertir_a_numerico(x):
    try:
        return pd.to_numeric(x)  # Intentar convertir el valor a numérico
    except ValueError:
        return x  # Retornar el valor original si la conversión falla

# Aplicar la conversión a todo el DataFrame
df = df.apply(convertir_a_numerico)

# Mostrar el DataFrame completo en formato tabular, sin índices
print(df.to_string(index=False))



# Identificamos las columnas que no son numéricas
columnas_no_numericas = df.select_dtypes(exclude=[int, float]).columns

# Iteramos sobre cada columna no numérica del dataframe
for columna in columnas_no_numericas:
    # Imprimimos el nombre de la columna actual
    print(f"Columna no numérica: {columna}")

    # Obtenemos la frecuencia de cada valor único en la columna
    valores_unicos = df[columna].value_counts()

    # Calculamos los cuartiles (Q1, Q2, Q3) de la frecuencia de valores
    cuartiles = valores_unicos.quantile([0.25, 0.5, 0.75])
    print("Cuartiles:")
    print(cuartiles)

    # Calculamos los percentiles (P10, P20, ..., P90) de la frecuencia de valores
    percentiles = valores_unicos.quantile([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
    print("\nPercentiles:")
    print(percentiles)
    print("\n")

# Identificamos las columnas que son numéricas
columnas_numericas = df.select_dtypes(include=[int, float]).columns

# Iteramos sobre cada columna numérica del dataframe
for columna in columnas_numericas:
    # Imprimimos el nombre de la columna actual
    print(f"Columna numérica: {columna}")

    # Obtenemos estadísticas descriptivas de la columna numérica
    estadisticas = df[columna].describe()
    print("Estadísticas descriptivas:")
    print(estadisticas)

    # Calculamos los cuartiles (Q1, Q2, Q3)
    cuartiles_numericos = df[columna].quantile([0.25, 0.5, 0.75])
    print("Cuartiles numéricos:")
    print(cuartiles_numericos)

    # Calculamos los percentiles (P10, P20, ..., P90)
    percentiles_numericos = df[columna].quantile([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
    print("\nPercentiles numéricos:")
    print(percentiles_numericos)
    print("\n")

import matplotlib.pyplot as plt
columnas_no_numericas = df.select_dtypes(exclude=[int, float]).columns

# Iteramos sobre cada columna no numérica del dataframe
for columna in columnas_no_numericas:
    # Imprimimos el nombre de la columna actual
    print(f"Columna no numérica: {columna}")

    # Obtenemos la frecuencia de cada valor único en la columna
    valores_unicos = df[columna].value_counts()

    # Calculamos los cuartiles (Q1, Q2, Q3) de la frecuencia de valores
    cuartiles = valores_unicos.quantile([0.25, 0.5, 0.75])
    print("Cuartiles:")
    print(cuartiles)

    # Calculamos los percentiles (P10, P20, ..., P90) de la frecuencia de valores
    percentiles = valores_unicos.quantile([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
    print("\nPercentiles:")
    print(percentiles)
    # Creamos un histograma de los datos
    plt.hist(valores_unicos, bins=30, density=True)

    # Agregamos título y etiquetas
    plt.title(f'Distribución exponencial de la columna {columna}')
    plt.xlabel('Valor')
    plt.ylabel('Frecuencia')

    # Mostramos el gráfico
    plt.show()

    print("\n")

# Identificamos las columnas que son numéricas
columnas_numericas = df.select_dtypes(include=[int, float]).columns

# Iteramos sobre cada columna numérica del dataframe
for columna in columnas_numericas:
    # Imprimimos el nombre de la columna actual
    print(f"Columna numérica: {columna}")

    # Obtenemos estadísticas descriptivas de la columna numérica
    estadisticas = df[columna].describe()
    print("Estadísticas descriptivas:")
    print(estadisticas)

    # Calculamos los cuartiles (Q1, Q2, Q3)
    cuartiles_numericos = df[columna].quantile([0.25, 0.5, 0.75])
    print("Cuartiles numéricos:")
    print(cuartiles_numericos)

    # Calculamos los percentiles (P10, P20, ..., P90)
    percentiles_numericos = df[columna].quantile([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
    print("\nPercentiles numéricos:")
    print(percentiles_numericos)
    # Creamos un histograma de los datos
    plt.hist(valores_unicos, bins=30, density=True)

    # Agregamos título y etiquetas
    plt.title(f'Distribución exponencial de la columna {columna}')
    plt.xlabel('Valor')
    plt.ylabel('Frecuencia')

    # Mostramos el gráfico
    plt.show()

    print("\n")

"""La distribución exponencial se utiliza en este caso porque se ajusta bien a la forma en que se distribuyen los datos en las columnas no numéricas del dataframe.

La distribución exponencial es una distribución de probabilidad continua que se utiliza para modelar la distribución de variables aleatorias que tienen una tasa constante de ocurrencia. En este caso, la distribución exponencial se utiliza para modelar la distribución de la frecuencia de cada valor único en las columnas no numéricas del dataframe.

La razón por la que se elige la distribución exponencial es que:


*   La distribución de los datos es asimétrica : La distribución de los datos en las columnas no numéricas del dataframe es asimétrica, lo que significa que hay una cola larga en un lado y una cola corta en el otro. La distribución exponencial se ajusta bien a este tipo de distribuciones.
*   La tasa de ocurrencia es constante : La tasa de ocurrencia de cada valor único en las columnas no numéricas del dataframe es constante, lo que significa que la probabilidad de que un valor determinado ocurra es la misma en todo el rango de valores. La distribución exponencial se ajusta bien a este tipo de situaciones.
*    La distribución es continua : La distribución de los datos en las columnas no numéricas del dataframe es continua, lo que significa que los valores pueden tomar cualquier valor dentro de un rango determinado. La distribución exponencial se ajusta bien a este tipo de distribuciones.




"""

#b. De al menos tres columnas seleccionadas por usted indique que datos son relevantes de estas, grafique la misma (puede ser dispersión o mapa de calor, otros), indique al menos 4 características por columna seleccionada.
# Importamos la librería matplotlib para crear gráficos
import matplotlib.pyplot as plt

# Seleccionamos las columnas no numéricas del dataframe
columnas_no_numericas = df.select_dtypes(exclude=[int, float]).columns

# Seleccionamos tres columnas no numéricas que existan en el dataframe
# Utilizamos una lista de comprensión para filtrar las columnas que existen en el dataframe
columnas_seleccionadas = [col for col in ['Sentirse ansioso', 'Dificultad para dormir por la noche', 'Problemas para concentrarse o tomar decisiones'] if col in df.columns]

# Iteramos sobre cada columna seleccionada
for columna in columnas_seleccionadas:
    # Imprimimos el nombre de la columna actual
    print(f"Columna no numérica: {columna}")

    # Obtenemos la frecuencia de cada valor único en la columna
    # Utilizamos el método value_counts() para obtener la frecuencia de cada valor
    valores_unicos = df[columna].value_counts()

    # Imprimimos las características de la columna
    print("Características:")
    # Calculamos la frecuencia promedio
    print(f"  - Frecuencia promedio: {valores_unicos.mean()}")
    # Calculamos la frecuencia mínima
    print(f"  - Frecuencia mínima: {valores_unicos.min()}")
    # Calculamos la frecuencia máxima
    print(f"  - Frecuencia máxima: {valores_unicos.max()}")
    # Calculamos la desviación estándar
    print(f"  - Desviación estándar: {valores_unicos.std()}")

    # Creamos un mapa de calor de la frecuencia
    # Utilizamos la función imshow() para crear un mapa de calor
    plt.figure(figsize=(10, 6))
    plt.imshow(valores_unicos.values.reshape(1, -1), cmap='hot', interpolation='nearest')
    # Agregamos un título al gráfico
    plt.title(f'Mapa de calor de la frecuencia de {columna}')
    # Agregamos etiquetas a los ejes
    plt.xlabel('Frecuencia')
    plt.ylabel('')
    # Mostramos el gráfico
    plt.show()

    # Imprimimos un salto de línea para separar los resultados
    print("\n")

#c. Obteniendo la media, mediana, moda con el uso de librerías, grafique un diagrama de cajas-bigote de al menos 3 columnas. Explique el resultado.
# Importamos las librerías necesarias
import matplotlib.pyplot as plt  # Librería para crear gráficos
import pandas as pd  # Librería para manipular datos

# Seleccionamos las columnas que queremos analizar
# Utilizamos una lista para seleccionar las columnas que queremos analizar
columnas_seleccionadas = ['Edad', 'Marca de tiempo', 'Problemas para concentrarse o tomar decisiones']

# Creamos un dataframe con las columnas seleccionadas
# Utilizamos la función select() para seleccionar las columnas del dataframe original
df_seleccionado = df[columnas_seleccionadas]
# Convertimos las columnas a valores numéricos
df_seleccionado = df_seleccionado.apply(pd.to_numeric, errors='coerce')
# Obtenemos la media de cada columna
# Utilizamos la función mean() para calcular la media de cada columna
media = df_seleccionado.mean()
print("Media:")  # Imprimimos el título de la sección
print(media)  # Imprimimos la media de cada columna

# Obtenemos la mediana de cada columna
# Utilizamos la función median() para calcular la mediana de cada columna
mediana = df_seleccionado.median()
print("\nMediana:")  # Imprimimos el título de la sección
print(mediana)  # Imprimimos la mediana de cada columna

# Obtenemos la moda de cada columna
# Utilizamos la función mode() para calcular la moda de cada columna
moda = df_seleccionado.mode()
print("\nModa:")  # Imprimimos el título de la sección
print(moda)  # Imprimimos la moda de cada columna

# Creamos un diagrama de cajas-bigote para cada columna
# Utilizamos la función boxplot() para crear un diagrama de cajas-bigote para cada columna
plt.figure(figsize=(10, 6))  # Creamos una figura con un tamaño de 10x6 pulgadas
plt.subplot(1, 3, 1)  # Creamos un subgráfico en la posición 1, 3, 1
plt.boxplot(df_seleccionado['Edad'])  # Creamos un diagrama de cajas-bigote para la columna 'Edad'
plt.title('Edad')  # Agregamos un título al subgráfico
plt.figure(figsize=(10, 6))  # Creamos una figura con un tamaño de 10x6 pulgadas
plt.subplot(1, 3, 2)  # Creamos un subgráfico en la posición 1, 3, 2
plt.boxplot(df_seleccionado['Marca de tiempo'])  # Creamos un diagrama de cajas-bigote para la columna 'Marca de tiempo'
plt.title('Marca de tiempo')  # Agregamos un título al subgráfico
plt.subplot(1, 3, 2)  # Creamos un subgráfico en la posición 1, 3, 2
plt.figure(figsize=(10, 6))  # Creamos una figura con un tamaño de 10x6 pulgadas
plt.subplot(1, 3, 1)  # Creamos un subgráfico en la posición 1, 3, 1
plt.boxplot(df_seleccionado['Problemas para concentrarse o tomar decisiones'])  # Creamos un diagrama de cajas-bigote para la columna 'Edad'
plt.title('Problemas para concentrarse o tomar decisiones')  # Agregamos un título al subgráfico